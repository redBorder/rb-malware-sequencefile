package net.redborder.malware.sequencefile.managers;

import net.redborder.malware.sequencefile.SequenceFile;
import net.redborder.malware.sequencefile.peons.SequencePeon;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.logger.RbLogger;
import net.redborder.taskassigner.NotifyListener;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.codehaus.jackson.map.ObjectMapper;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by andresgomez on 3/2/15.
 */
public class SequenceManager extends Thread implements NotifyListener {

    private Queue<SequencePeon> peons;
    private boolean running = false;
    Object monitor = new Object();
    private Logger log = null;
    CuratorFramework client;
    String task = null;
    Map<String, Object> maps;
    ObjectMapper mapper;

    public SequenceManager() {
        // OozieManager.init();  // Now the OozieManager is initiated by the OozieLeader
        init();
    }

    private void init() {
        mapper = new ObjectMapper();
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        log = RbLogger.getLogger(SequenceManager.class.getName());
        peons = new LinkedList<>();
        running = true;
    }

    @Override
    public void run() {
        while (running) {

            waitTasks();

            List<String> hdfsSeqFiles = new ArrayList<>();

            // We wait until all peons end up
            while(peons.size()>0) {
                SequencePeon peon = peons.remove();
                try {
                    peon.join();

                    hdfsSeqFiles.add(peon.getHdfsFile());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            for (String file : hdfsSeqFiles){
                //We send a sequence file to OozieLeader using /rb_malware2/oozie/task
                SequenceFile hdfsfile = new SequenceFile();
                hdfsfile.addS3FilePath(file);
                /*    OozieManager.updateSeqFiles(hdfsSeqFiles);
                // Escribir en Zookeeper el ficheros
                //String taskName;
                //taskName = UUID.randomUUID().toString();
                //client.create().forPath("/rb_malware2/oozie/tasks/" + taskName, mapper.writeValueAsBytes(hdfsSeqFiles.asMap()));
                //libreria.gotoWork();
                //OozieManager.start();
                // byte[] zkData = client.getData().forPath("/rb_malware2/oozie/tasks/"+children);
                */



            }

        }

    }


    // Executed by Curator library
    @Override
    public void time2Work(){
        String children;

        try {
            children = client.getChildren().forPath("/rb_malware2/tasks").get(0);
            //Leer de ZK
            byte[] zkData = client.getData().forPath("/rb_malware2/tasks/"+children);

            maps = (Map<String, Object>) mapper.readValue(zkData, Map.class);
            client.delete().forPath("/rb_malware2/tasks/"+children);
        } catch (Exception e) {
            e.printStackTrace();
        }

        SequenceFile sequenceFile = new SequenceFile(maps);
        SequencePeon peon = new SequencePeon(sequenceFile);
        // Starting a peon
        peon.start();
        // Peon has ended
        peons.add(peon);

        synchronized (monitor) {
            monitor.notifyAll();
        }

    }


    public void waitTasks() {
        try {
            synchronized (monitor) {
                monitor.wait();
                log.log(Level.INFO, "Sequence Manager running");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void close() {
        running = false;
    }
}
