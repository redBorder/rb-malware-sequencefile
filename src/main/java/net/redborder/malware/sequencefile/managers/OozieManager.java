package net.redborder.malware.sequencefile.managers;

import net.redborder.clusterizer.NotifyListener;
import net.redborder.malware.sequencefile.peons.OoziePeon;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.logger.RbLogger;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.barriers.DistributedBarrier;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.log4j.Logger;
import org.codehaus.jackson.map.ObjectMapper;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;

/**
 * Created by Lito on 11/2/15.
 */
public class OozieManager extends Thread implements NotifyListener {

    private static OozieManager theInstance = null;
    List<String> seqFiles;
    Object monitor = new Object();
    private Logger log = null;
    private boolean running = false;
    CuratorFramework client;
    private Queue<OoziePeon> peons;
    ObjectMapper mapper;
    Object canClose;
    InterProcessSemaphoreMutex mutex;
    DistributedBarrier barrierOozieSeq;
    OozieManager.Status status = Status.CLOSE;

    enum Status {
        INIT, RUNNING, CLOSING, CLOSE
    }


    private OozieManager() {

        seqFiles = new ArrayList<>();
        init();
    }


    public static OozieManager getInstance() {
        if (theInstance == null) {
            theInstance = new OozieManager();
        }
        return theInstance;
    }


    private void init() {
        status = Status.INIT;
        log = RbLogger.getLogger(OozieManager.class);
        log.info("Status [" + status.name() + "]");
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        peons = new ConcurrentLinkedQueue<>();
        running = true;
        mapper = new ObjectMapper();
        canClose = new Object();
        mutex = new InterProcessSemaphoreMutex(client, "/rb_malware/oozie/mutex");
        barrierOozieSeq = new DistributedBarrier(client, "/rb_malware/seq-oozie/oozie_must_wait");
    }


    @Override
    public void run() {
        status = Status.RUNNING;
        log.info("Status [" + status.name() + "]");
        while (status.equals(Status.RUNNING) || status.equals(Status.CLOSING)) {
            log.debug("Wait on tasks");
            waitTasks();
            log.debug("leave on tasks");

            // We wait until all peons end up
            OoziePeon peon;

            while ((peon = peons.poll()) != null) {
                log.debug("OozieManager:  Peon has ended");
                try {
                    peon.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // Peon has ended

                String taskName = UUID.randomUUID().toString();
                Map<String, Object> map = new HashMap<>();
                map.put("status", peon.getStatus());
                map.put("path", peon.getIdJob());
                map.put("idjob", peon.getPath());

                try {
                    log.debug("Wait on Barrier");
                    barrierOozieSeq.waitOnBarrier(5, TimeUnit.MINUTES);
                    if (client.checkExists().forPath("/rb_malware/seq-oozie/oozie_must_wait") != null) {
                        barrierOozieSeq.removeBarrier();
                        log.warn("Timeout! Removed [/rb_malware/seq-oozie/oozie_must_wait] barrier.");
                    }
                    barrierOozieSeq.setBarrier();
                    log.debug("Set Barrier");
                    client.create().forPath("/rb_malware/seq-oozie/leases/" + taskName, mapper.writeValueAsBytes(map));
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }

            if (status.equals(Status.CLOSING)) {
                status = Status.CLOSE;
                client.close();
                log.info("Status [" + status.name() + "]");
                synchronized (canClose){
                    canClose.notify();
                }
            }
        }

    }


    @Override
    public void time2Work() {
        log.debug("A new file is avaliable");

        if(status.equals(Status.RUNNING)) {
            try {
                // AQUIRE MUTEX
                mutex.acquire();
                // Read of ZK
                List<String> childrens = client.getChildren().forPath("/rb_malware/oozie/peontasks");

                if (!childrens.isEmpty()) {
                    String children = childrens.get(0);
                    log.info("Children is: " + children);
                    byte[] zkData = client.getData().forPath("/rb_malware/oozie/peontasks/" + children);
                    String file = new String(zkData, "UTF-8");
                    log.info("The new file is: " + file);
                    client.delete().forPath("/rb_malware/oozie/peontasks/" + children);

                    OoziePeon peonWork = new OoziePeon(file);
                    //Starting a peon
                    peonWork.start();
                    peons.add(peonWork);

                    synchronized (monitor) {
                        monitor.notifyAll();
                    }
                }

                //RELEASE MUTEX
                mutex.release();

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    public void waitTasks() {
        try {
            synchronized (monitor) {
                monitor.wait();
                log.info("OozieManager: running");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void close() {
        status = Status.CLOSING;
        log.info("Status [" + status.name() + "]");
        try {
           synchronized (canClose) {canClose.wait(); }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
