package net.redborder.malware.sequencefile.leader;

import net.redborder.clusterizer.ZkTasksHandler;
import net.redborder.malware.sequencefile.managers.OozieManager;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.ConfigFileModifier;
import net.redborder.malware.sequencefile.util.logger.RbLogger;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.barriers.DistributedBarrier;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;

import org.apache.log4j.Logger;

/**
 * Created by Maria on 26/02/15.
 */
public class OozieLeader extends Thread {

    private static final long ONE_MINUTE = 60000;
    private OozieManager oozieManager;
    private ZkTasksHandler oozieTasksHandler;
    CuratorFramework client;
    ObjectMapper mapper;
    TaskWatcher incomingTaskWatcher;
    Queue<String> incomingSeqFiles;

    Object canClose = new Object();
    private Logger log = null;
    String hostname;
    final Object waitTasks = new Object();
    DistributedBarrier barrierSeqOozie;
    OozieLeader.Status status = Status.CLOSE;
    OozieLeader.Leader leader = Leader.NOT_LEADER;

    enum Status {
        INIT, RUNNING, CLOSING, CLOSE
    }

    enum Leader {
        LEADER, NOT_LEADER
    }


    public OozieLeader() {
        init();
    }

    private void init() {
        status = Status.INIT;
        log = RbLogger.getLogger(OozieLeader.class);
        log.info("Status [" + status.name() + "]");
        incomingSeqFiles = new ConcurrentLinkedQueue<>();
        mapper = new ObjectMapper();
        // Starting a ZK client
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        // Setting a ZKTaskHandler to send task to OozieManagers
        oozieTasksHandler = new ZkTasksHandler(ConfigFile.getInstance().getZkConnect(), "/rb_malware/oozie/leader");
        barrierSeqOozie = new DistributedBarrier(client, "/rb_malware/seq-oozie/seq_must_wait");


        // Adding a new OozieManager
        oozieManager = OozieManager.getInstance();
        oozieTasksHandler.addListener(oozieManager);

        // OozieLeader look for incoming tasks
        incomingTaskWatcher = new TaskWatcher();

        try {
            if (client.checkExists().forPath("/rb_malware/oozie/peontasks") == null) {
                client.create().forPath("/rb_malware/oozie/peontasks");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }


        try {
            hostname = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
        try {
            if (client.checkExists().forPath("/rb_malware/oozie/tasks") == null) {
                client.create().forPath("/rb_malware/oozie/tasks");
                client.getChildren().usingWatcher(incomingTaskWatcher).forPath("/rb_malware/oozie/tasks");
            } else {
                //client.delete().deletingChildrenIfNeeded().forPath("/rb_malware/oozie/tasks");
                //client.create().creatingParentsIfNeeded().forPath("/rb_malware/oozie/tasks");
                client.getChildren().usingWatcher(incomingTaskWatcher).forPath("/rb_malware/oozie/tasks");
            }

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // Run a sequenceManager
    @Override
    public synchronized void start() {
        super.start();
        status = Status.RUNNING;
        log.info("Status [" + status.name() + "]");
        oozieManager.start();
    }


    public void waitTasks() {
        synchronized (waitTasks) {
            try {
                waitTasks.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void notifyTasks() {
        synchronized (waitTasks) {
            waitTasks.notifyAll();
        }
    }

    @Override
    public void run() {
        while (status.equals(Status.RUNNING) || status.equals(Status.CLOSING)) {
            log.info("Leader [" + leader.name() + "]");
            if (oozieTasksHandler.isLeader()) {
                leader = Leader.LEADER;
                //The leader must watch for incoming Tasks and send them to an OozieManager using oozieTasksHandler
                try {
                    //If there are an incoming File, we write them in /rb_malware/oozie/peontasks
                    String seqFile;

                    while ((seqFile = incomingSeqFiles.poll()) != null) {
                        // seqFile = incomingSeqFiles.remove(0);
                        log.info("New File: " + seqFile + " -- Waiting Files: " + incomingSeqFiles.size());

                        /*// We send the files to the OozieManager*/

                        String taskName = UUID.randomUUID().toString();
                        log.info("New Task set in '/rb_malware/oozie/peontasks/" + taskName + "' ");
                        // Create a task and order a SequenceManager to work
                        client.create().forPath("/rb_malware/oozie/peontasks/" + taskName, seqFile.getBytes());
                        oozieTasksHandler.goToWork(true);
                    }

                    // If there were any incoming file, we go to sleep.
                    if (status.equals(Status.RUNNING)) {
                        waitTasks();
                    } else if (status.equals(Status.CLOSING)) {
                        client.close();
                        status = Status.CLOSE;
                        log.info("Status [" + status.name() + "]");
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }

            } else {
                try {
                    leader = Leader.NOT_LEADER;
                    log.info("Sleeping... I'm not a leader!");
                    Thread.sleep(ONE_MINUTE);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (status.equals(Status.CLOSING)) {
                synchronized (canClose) {
                    try {
                        canClose.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }

    }

    public void reload(){
        if(leader.equals(Leader.LEADER)){
            try {
                log.info("Configuring hdfs file...");
                ConfigFileModifier.setConfiguration();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public void closing(){
        status = Status.CLOSING;
        oozieTasksHandler.end();
        log.info("Status [" + status.name() + "]");
    }

    public void close() {
        oozieManager.close();
        notifyTasks();
        synchronized (canClose) {
            canClose.notify();
        }
    }

    /*
     * This Class look for an incoming task in /rb_malware/oozie/tasks
     */
    public class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {
            Watcher.Event.EventType type = watchedEvent.getType();
            if (type.equals(Watcher.Event.EventType.NodeChildrenChanged)) {
                if (oozieTasksHandler.isLeader()) {


                    List<String> childrens = client.getChildren().forPath(watchedEvent.getPath());
                    log.debug("New tasks: " + childrens);

                    for (String children : childrens) {
                        String eventPath = watchedEvent.getPath() + "/" + children;
                        byte[] zkData = client.getData().forPath(eventPath);
                        //  We delete the readed incoming-task
                        client.delete().forPath(eventPath);
                        //String contained at zk
                        String seqFile = new String(zkData, "UTF-8");
                        incomingSeqFiles.add(seqFile);
                        log.info("Name of the incoming task: " + seqFile);
                    }
                    notifyTasks();
                    barrierSeqOozie.removeBarrier();
                }
            }

            if (client.getState().equals(CuratorFrameworkState.STARTED)) {
                // incomingTaskManager go on Watching a new incoming task
                client.getChildren().usingWatcher(incomingTaskWatcher).forPath("/rb_malware/oozie/tasks");
            }
        }
    }

}
