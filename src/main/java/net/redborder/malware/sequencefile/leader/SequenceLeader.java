package net.redborder.malware.sequencefile.leader;

import net.redborder.malware.sequencefile.SequenceFile;
import net.redborder.malware.sequencefile.managers.SequenceManager;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.logger.RbLogger;
import net.redborder.taskassigner.Task;
import net.redborder.taskassigner.ZkTasksHandler;
import org.apache.commons.lang.ArrayUtils;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;
import org.apache.curator.framework.recipes.locks.Lease;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.jets3t.service.S3Service;
import org.jets3t.service.ServiceException;
import org.jets3t.service.StorageObjectsChunk;
import org.jets3t.service.impl.rest.httpclient.RestS3Service;
import org.jets3t.service.model.StorageObject;
import org.jets3t.service.security.AWSCredentials;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;


public class SequenceLeader extends Thread {
    private static final long ONE_MINUTE = 60000;
    private static final Integer NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
    private static final Integer SEQ_FILE_ON_WORKERS = ConfigFile.getInstance().getFromGeneral("seq_file_on_workers");
    private ZkTasksHandler tasksHandler;
    private SequenceManager sequenceManager;
    private Boolean running = false;
    private Queue<Lease> leases;
    AWSCredentials awsCredentials;
    S3Service s3Service;
    InterProcessSemaphoreV2 semaphore;
    CuratorFramework client;
    LeaseWatcher leaseWatcher;
    private static Logger log = null;

    public SequenceLeader() {
        init();
    }

    private void init() {
        log = RbLogger.getLogger(SequenceLeader.class.getName());
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        awsCredentials = new AWSCredentials((String) ConfigFile.getInstance().getFromGeneral("aws_access"), (String) ConfigFile.getInstance().getFromGeneral("aws_secret"));
        s3Service = new RestS3Service(awsCredentials);

        tasksHandler = new ZkTasksHandler(ConfigFile.getInstance().getZkConnect(), "/rb-malware/sequence-file");
        sequenceManager = new SequenceManager();
        System.out.println("Addded Sequence manager listener");
        tasksHandler.addListener(sequenceManager);
        System.out.println("NUM WORKERS: " + tasksHandler.numWorkers());
        Integer max_seq_files = tasksHandler.numWorkers() * SEQ_FILE_ON_WORKERS.intValue();
        semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/semaphore", max_seq_files);
        leases = new LinkedList<>();
        leaseWatcher = new LeaseWatcher();
        try {
            if (client.checkExists().forPath("/rb-malware/leases") == null) {
                client.create().withMode(CreateMode.EPHEMERAL).forPath("/rb-malware/leases");
                client.getData().usingWatcher(leaseWatcher).forPath("/rb-malware/leases");
            } else {
                client.getData().usingWatcher(leaseWatcher).forPath("/rb-malware/leases");
            }

            Thread.sleep(10000);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        running = true;

    }

    @Override
    public synchronized void start() {
        super.start();
        sequenceManager.start();
    }

    @Override
    public void run() {
        while (running) {
            System.out.println("LEADER: " + tasksHandler.isLeader());
            if (tasksHandler.isLeader()) {
                try {
                    List<Task> tasks = new ArrayList<>();
                    Integer numWorkers = tasksHandler.numWorkers();

                    Integer numS3Files = NUM_FILE_ON_SEQ * numWorkers * SEQ_FILE_ON_WORKERS;

                    log.log(Level.INFO, "Number of S3Files [ " + numS3Files.toString() + " ]");

                    StorageObjectsChunk inputChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/input", null, numS3Files, null, false);
                    StorageObject inputObjects[] = inputChunk.getObjects();
                    StorageObjectsChunk analizedChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/analized", null, numS3Files - inputObjects.length, null, false);
                    StorageObject analizedObjects[] = analizedChunk.getObjects();
                    StorageObject mixedObjects[] = (StorageObject[]) ArrayUtils.addAll(inputObjects, analizedObjects);


                    if (mixedObjects.length > 0) {
                        List<StorageObject> objects = Arrays.asList(mixedObjects);
                        Collections.reverse(objects);

                        SequenceFile file = new SequenceFile();
                        log.log(Level.INFO, "Number of S3Files [ " + numS3Files.toString() + " ]");

                        for (StorageObject o : objects) {
                            if (!file.isDone()) {
                                file.addS3FilePath(o.getKey());
                            } else {
                                log.log(Level.INFO, "File done and completed.");
                                Lease lease = semaphore.acquire();
                                leases.add(lease);
                                tasks.add(file);
                                file = new SequenceFile();
                                file.addS3FilePath(o.getKey());
                            }
                        }

                        if (!file.isDone()) {
                            log.log(Level.INFO, "File done but it isn't completed.");
                            Lease lease = semaphore.acquire();
                            leases.add(lease);
                            file.done();
                            tasks.add(file);
                        }

                        if (tasks.size() > 0) {
                            log.log(Level.INFO, "Number of tasks:" + tasks.size());
                            tasksHandler.setTasks(tasks);
                            tasksHandler.wakeup();
                        }
                    }
                } catch (ServiceException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    log.log(Level.INFO, "Sleeping...");

                    Thread.sleep(ONE_MINUTE);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void close() {
        running = false;
        sequenceManager.close();
    }

    public class LeaseWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {
            System.out.println(Thread.currentThread().getId() + " [WATCH] WorkersWatcher: " + watchedEvent);
            Watcher.Event.EventType type = watchedEvent.getType();

            if (type.equals(Watcher.Event.EventType.NodeChildrenChanged)) {
                System.out.print("Leases added!");
                if (tasksHandler.isLeader()) {
                    // TODO Detectar que fichero sequencial se ha terminado.
                    semaphore.returnLease(leases.remove());
                } else {
                    System.out.println(" But im not the leader, so lets ignore it.");
                }
            }

            if (client.getState().equals(CuratorFrameworkState.STARTED)) {
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb-malware/leases");
            }
        }
    }
}
