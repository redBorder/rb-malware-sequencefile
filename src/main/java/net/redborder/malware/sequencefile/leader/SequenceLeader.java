package net.redborder.malware.sequencefile.leader;

import net.redborder.clusterizer.Task;
import net.redborder.clusterizer.ZkTasksHandler;
import net.redborder.malware.sequencefile.SequenceFile;
import net.redborder.malware.sequencefile.managers.SequenceManager;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.S3HDFSDB;
import net.redborder.malware.sequencefile.util.logger.RbLogger;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.barriers.DistributedBarrier;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;
import org.apache.curator.framework.recipes.locks.Lease;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.log4j.Logger;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;
import org.jets3t.service.S3Service;
import org.jets3t.service.ServiceException;
import org.jets3t.service.StorageObjectsChunk;
import org.jets3t.service.impl.rest.httpclient.RestS3Service;
import org.jets3t.service.model.S3Object;
import org.jets3t.service.model.StorageObject;
import org.jets3t.service.security.AWSCredentials;
import org.joda.time.DateTime;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;


public class SequenceLeader extends Thread {
    private static final long ONE_MINUTE = 60000;
    private static final String SEQUENCE_FILE_PATH = "hdfs://hadoopnamenode.redborder.cluster:8020/user/oozie/sequence_file";
    private  Integer NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
    private  Integer MAX_MULTIPLE_SEQ_FILE = ConfigFile.getInstance().getFromGeneral("max_multiple_seq_file");
    private  Long MAX_SEQ_FILE_SIZE = new Long((Integer)ConfigFile.getInstance().getFromGeneral("max_seq_file_size"));
    private ZkTasksHandler sequenceTasksHandler;
    private SequenceManager sequenceManager;
    private Queue<Lease> leases;
    private S3HDFSDB database;
    AWSCredentials awsCredentials;
    S3Service s3Service;
    InterProcessSemaphoreV2 semaphore;
    CuratorFramework client;
    LeaseWatcher leaseWatcher;
    private Logger log = null;
    int i = 1;
    String hostname;
    ObjectMapper mapper;
    String task_assigned;
    String taskName = null;
    DistributedBarrier barrierOozieSeq;
    Object canClose = new Object();
    SequenceLeader.Status status = Status.CLOSE;
    SequenceLeader.Leader leader = Leader.NOT_LEADER;


    enum Status {
        INIT, RUNNING, CLOSING, CLOSE
    }

    enum Leader {
        LEADER, NOT_LEADER
    }

    public SequenceLeader() {
        init();
    }

    private void init() {

        status = Status.INIT;
        log = RbLogger.getLogger(SequenceLeader.class);
        log.info("Status [" + status.name() + "]");
        mapper = new ObjectMapper();
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 5);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        awsCredentials = new AWSCredentials((String) ConfigFile.getInstance().getFromGeneral("aws_access"), (String) ConfigFile.getInstance().getFromGeneral("aws_secret"));
        s3Service = new RestS3Service(awsCredentials);
        barrierOozieSeq = new DistributedBarrier(client, "/rb_malware/seq-oozie/oozie_must_wait");
        sequenceTasksHandler = new ZkTasksHandler(ConfigFile.getInstance().getZkConnect(), "/rb_malware/sequence-file");
        sequenceManager = SequenceManager.getInstance();
        System.out.println("Added Sequence manager listener");
        sequenceTasksHandler.addListener(sequenceManager);
        semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/sequence-file/semaphore", MAX_MULTIPLE_SEQ_FILE.intValue());

        leases = new LinkedList<>();
        leaseWatcher = new LeaseWatcher();

        database = S3HDFSDB.getInstance();

        try {
            if (client.checkExists().forPath("/rb_malware/sequence-file/tasks") == null) {
                client.create().creatingParentsIfNeeded().forPath("/rb_malware/sequence-file/tasks");
            }

            hostname = InetAddress.getLocalHost().getHostName();
            if (client.checkExists().forPath("/rb_malware/seq-oozie") == null) {
                client.create().forPath("/rb_malware/seq-oozie");
            }

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // Run a sequenceManager
    @Override
    public synchronized void start() {
        super.start();
        sequenceManager.start();
    }

    @Override
    public void run() {
        status = Status.RUNNING;
        log.info("Status [" + status.name() + "]");
        while (status.equals(Status.RUNNING)) {
            log.info("Leader [" + leader.name() + "]");
            if (sequenceTasksHandler.isLeader()) {
                if(leader.equals(Leader.NOT_LEADER)){
                    leader = Leader.LEADER;
                    log.info("Leader [" + leader.name() + "]");

                    try {
                        if (client.checkExists().forPath("/rb_malware/seq-oozie/leases") == null) {
                            client.create().forPath("/rb_malware/seq-oozie/leases");
                            client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/seq-oozie/leases");
                        } else {
                            client.delete().deletingChildrenIfNeeded().forPath("/rb_malware/seq-oozie/leases");
                            client.create().forPath("/rb_malware/seq-oozie/leases");
                            client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/seq-oozie/leases");
                        }

                        if(client.checkExists().forPath("/rb_malware/sequence-file/semaphore") != null) {
                            client.delete().deletingChildrenIfNeeded().forPath("/rb_malware/sequence-file/semaphore");
                            semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/sequence-file/semaphore", MAX_MULTIPLE_SEQ_FILE.intValue());
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                }
                try {
                    Task tasks = null;

                    Integer numS3Files = NUM_FILE_ON_SEQ;

                    StorageObjectsChunk inputChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/input", null, numS3Files, null, false);
                    StorageObject inputObjects[] = inputChunk.getObjects();
                    StorageObjectsChunk analyzedChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/analyzed", null, numS3Files - inputObjects.length, null, false);
                    StorageObject analyzedObjects[] = analyzedChunk.getObjects();
                    StorageObject mixedObjects[];
                    mixedObjects = (StorageObject[]) ArrayUtils.addAll(inputObjects, analyzedObjects);


                    if (mixedObjects.length > 0 || database.getBufferedObjects().size()>0) {
                        log.debug("Number of S3Files to read [ " + numS3Files.toString() + " ]");
                        //Have peons finished?
                        Lease lease = semaphore.acquire();
                        if(!status.equals(Status.RUNNING)){
                            semaphore.returnLease(lease);
                        } else {
                            leases.add(lease);
                            log.debug("Number of leases: " + leases.size());
                            StorageObject bufferedObjects[] = (StorageObject[]) database.getBufferedObjects().toArray();
                            int numBufferedObjects = database.getBufferedObjects().size();
                            int numInputS3files = numS3Files - numBufferedObjects;
                            if (numInputS3files < 0){
                                numInputS3files = 0;
                            }

                            inputChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/input", null, numS3Files, null, false);
                            inputObjects = inputChunk.getObjects();
                            int numAnalyzedS3files = numInputS3files - inputObjects.length;

                            analyzedChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/analyzed", null, numAnalyzedS3files, null, false);
                            analyzedObjects = analyzedChunk.getObjects();


                            if (numBufferedObjects>0){
                                mixedObjects = bufferedObjects;
                                database.removeBufferedObjects();
                            }
                            if (inputObjects.length>0){
                                mixedObjects = (StorageObject[]) ArrayUtils.addAll(mixedObjects,inputObjects);
                            }
                            if (analyzedObjects.length>0){
                                mixedObjects = (StorageObject[]) ArrayUtils.addAll(mixedObjects,analyzedObjects);
                            }



                            if (mixedObjects.length > 0) {
                                List<StorageObject> objects = Arrays.asList(mixedObjects);
                                Collections.reverse(objects);

                                SequenceFile file = new SequenceFile();
                                log.debug("Number of mixed objects: " + mixedObjects.length);
                                int numberAnalyzing = 0;
                                long currentSize = 0;

                                for (StorageObject o : objects) {
                                    System.out.println("El objeto actual es: "+o.getKey());
                                    currentSize = currentSize + o.getContentLength();
                                    System.out.println("** MAX_SEQ_FILE_SIZE ES: " + (MAX_SEQ_FILE_SIZE*1000000));
                                    System.out.println("** CurrentSize es: " + currentSize);
                                    if(currentSize>(MAX_SEQ_FILE_SIZE*1000000) && file.sizeNow()>0 ){
                                        System.out.println("** El archivo ha superado 1GB. Intentando con el siguiente...");
                                        currentSize = currentSize - o.getContentLength();
                                        database.addBufferedObject(o);
                                        continue;
                                    }else {
                                        if (!database.isAnalyzing(o.getKey())) {
                                            StorageObject storageObject = new S3Object();
                                            storageObject.setBucketName("redborder");
                                            String path = o.getKey();
                                            System.out.println("** El archivo escogido es: "+ o.getKey());
                                            System.out.println("** El tamaño del objeto en s3 es: " + o.getContentLength());
                                            String filename = "";
                                            String newFileName;
                                            String pathToFile = "rbdata/rb_malware";
                                            if (path.contains("rbdata/rb_malware/input")) {
                                                filename = path.substring((pathToFile + "/input/").length());
                                            } else if (path.contains("rbdata/rb_malware/analyzed/")) {
                                                filename = path.substring((pathToFile + "/analyzed/").length());
                                            }
                                            String[] names = filename.split("==");
                                            Long timestamp = System.currentTimeMillis();
                                            if (names.length > 1) {
                                                filename = timestamp + "==" + names[names.length - 1];
                                            } else {
                                                filename = timestamp + "==" + filename;
                                            }


                                            newFileName = "rbdata/rb_malware" + "/analyzed/" + filename;


                                            log.debug("Moving S3 file " + path + " to " + newFileName);
                                            database.addEntry(newFileName);
                                            storageObject.setKey(newFileName);
                                            s3Service.renameObject("redborder", path, storageObject);
                                            System.out.println("** Metiendo el archivo: " + path);
                                            file.addS3FilePath(newFileName);
                                        } else {
                                            numberAnalyzing++;
                                        }
                                    }
                                }

                                if (numberAnalyzing == mixedObjects.length) {
                                    log.info("All files are being analyzed");
                                    leases.remove(lease);
                                    semaphore.returnLease(lease);
                                    Thread.sleep(ONE_MINUTE / 2);
                                }
                                System.out.println("** Hay "+ file.sizeNow() +" archivos individuales.");
                                log.debug("File done and it has " + file.sizeNow() + " individual files. ");
                                file.done();

                                DateTime date = new DateTime();
                                String path = SEQUENCE_FILE_PATH + "/" + date.getYear() + "/" + date.getMonthOfYear() + "/" + date.getDayOfMonth() + "/" + date.getHourOfDay();
                                Long timestamp = System.currentTimeMillis();
                                String hash = DigestUtils.md5Hex(file.getS3FilesPaths().toString().getBytes());
                                String fileKey = timestamp + "-" + hash + ".seq";
                                file.setHDFSPath(path + "/" + fileKey);

                                database.addEntry(file.getHDFSPath(), file.getS3FilesPaths());

                                tasks = file;


                                if (file.sizeNow() > 0) {
                                    log.debug("SETTING TASK: " + i);
                                    i++;
                                    byte[] aaa = mapper.writeValueAsBytes(file.asMap());
                                    taskName = UUID.randomUUID().toString();

                                    client.create().forPath("/rb_malware/sequence-file/tasks/" + taskName, mapper.writeValueAsBytes(file.asMap()));
                                    sequenceTasksHandler.goToWork(true);

                                    task_assigned = " (" + tasks + ") ";
                                }
                            }
                        }
                    } else {
                        log.info("No s3 files ... Sleep [1 min]");
                        try {
                            Thread.sleep(ONE_MINUTE);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                } catch (ServiceException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    log.info("Sleeping... I'm not a leader!");
                    Thread.sleep(ONE_MINUTE);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void closing(){
        status=Status.CLOSING;
        log.info("Status [" + status.name() + "]");
        sequenceManager.close();
    }

    public void close() {
        while(!leases.isEmpty()){
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("Waiting while ooziePeons ending ... OoziePeons running #" + leases.size());
        }

        sequenceTasksHandler.end();
        client.close();
        status = Status.CLOSE;
        log.info("Status [" + status.name() + "]");

    }
    public void reload(){
    NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
    MAX_MULTIPLE_SEQ_FILE = ConfigFile.getInstance().getFromGeneral("max_multiple_seq_file");
    }

    public class LeaseWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {
            log.info(Thread.currentThread().getId() + " [WATCH] LeasesWatcher: " + watchedEvent);
            Watcher.Event.EventType type = watchedEvent.getType();
            if (type.equals(Watcher.Event.EventType.NodeChildrenChanged)) {
                log.debug("Leases added!");
                if (sequenceTasksHandler.isLeader()) {

                    String eventPath = watchedEvent.getPath() + "/" + client.getChildren().forPath(watchedEvent.getPath()).get(0);
                    byte[] zkData = client.getData().forPath(eventPath);
                    client.delete().forPath(eventPath);

                    //String contained at zk
                    String str = new String(zkData, "UTF-8");

                    log.info("Oozie Job finished:  [" + str + "]");

                    //Recolect s3objects that have been analyzed and put metadata info "analyzing" to "no"
                    Map<String, Object> data = mapper.readValue(str, Map.class);
                    String path = (String) data.get("idjob");
                    //Delete files that have been analyzed from database
                    Boolean mustLeave = database.removeEntry(path);

                    if (mustLeave && leases.size() > 0) {
                        log.info("REMOVE LEASE!");
                        semaphore.returnLease(leases.remove());
                    }
                    barrierOozieSeq.removeBarrier();
                }
            }

            if (client.getState().equals(CuratorFrameworkState.STARTED)) {
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/seq-oozie/leases");
            }
        }
    }
}
