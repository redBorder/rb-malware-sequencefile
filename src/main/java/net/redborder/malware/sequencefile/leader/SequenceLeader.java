package net.redborder.malware.sequencefile.leader;

import com.amazonaws.util.IOUtils;
import net.redborder.clusterizer.Task;
import net.redborder.clusterizer.ZkTasksHandler;
import net.redborder.malware.sequencefile.SequenceFile;
import net.redborder.malware.sequencefile.managers.SequenceManager;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.S3HDFSDB;
import net.redborder.malware.sequencefile.util.aerospike.AeroSpikeManager;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.barriers.DistributedBarrier;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;
import org.apache.curator.framework.recipes.locks.Lease;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.log4j.Logger;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;
import org.jets3t.service.S3Service;
import org.jets3t.service.ServiceException;
import org.jets3t.service.StorageObjectsChunk;
import org.jets3t.service.impl.rest.httpclient.RestS3Service;
import org.jets3t.service.model.S3Object;
import org.jets3t.service.model.StorageObject;
import org.jets3t.service.security.AWSCredentials;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.net.InetAddress;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.TimeUnit;


public class SequenceLeader extends Thread {
    private static final long ONE_MINUTE = 60000;
    private static final String SEQUENCE_FILE_PATH = "/user/oozie/sequence_file";
    private Integer NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
    private Integer MAX_MULTIPLE_SEQ_FILE = ConfigFile.getInstance().getFromGeneral("max_multiple_seq_file", 1);
    private Long MAX_SEQ_FILE_SIZE = ((Integer) ConfigFile.getInstance().getFromGeneral("max_seq_file_size", 8)).longValue();
    private String bucket = ConfigFile.getInstance().getFromGeneral("aws_bucket", "malware");
    private Long timeWindow = ((Integer) ConfigFile.getInstance().getFromGeneral("time_window", 4)).longValue();
    private ZkTasksHandler sequenceTasksHandler;
    private SequenceManager sequenceManager;
    private Queue<Lease> leases;
    private S3HDFSDB database;
    AWSCredentials awsCredentials;
    S3Service s3Service;
    InterProcessSemaphoreV2 semaphore;
    CuratorFramework client;
    LeaseWatcher leaseWatcher;
    private static final Logger log = Logger.getLogger(SequenceLeader.class);
    String hostname;
    ObjectMapper mapper;
    String task_assigned;
    String taskName = null;
    DistributedBarrier barrierOozieSeq;
    SequenceLeader.Status status = Status.CLOSE;
    SequenceLeader.Leader leader = Leader.NOT_LEADER;
    AeroSpikeManager fileKnownChecker;
    String lastFile = null;
    DateTime currentDate = new DateTime();


    enum Status {
        INIT, RUNNING, CLOSING, CLOSE
    }

    enum Leader {
        LEADER, NOT_LEADER
    }

    public SequenceLeader() {
        init();
    }

    private void init() {
        status = Status.INIT;
        log.trace("At init method");
        log.info("Status [" + status.name() + "]");
        mapper = new ObjectMapper();
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 5);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        awsCredentials = new AWSCredentials((String) ConfigFile.getInstance().getFromGeneral("aws_access", null), (String) ConfigFile.getInstance().getFromGeneral("aws_secret", null));
        s3Service = new RestS3Service(awsCredentials);
        barrierOozieSeq = new DistributedBarrier(client, "/rb_malware/seq-oozie/oozie_must_wait");
        sequenceManager = SequenceManager.getInstance();
        sequenceManager.start();
        sequenceTasksHandler = new ZkTasksHandler(ConfigFile.getInstance().getZkConnect(), "/rb_malware/sequence-file");

        sequenceTasksHandler.addListener(sequenceManager);
        semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/sequence-file/semaphore", MAX_MULTIPLE_SEQ_FILE.intValue());

        leases = new LinkedList<>();
        leaseWatcher = new LeaseWatcher();

        database = S3HDFSDB.getInstance();
        fileKnownChecker = AeroSpikeManager.getInstance();

        try {
            if (client.checkExists().forPath("/rb_malware/sequence-file/tasks") == null) {
                client.create().creatingParentsIfNeeded().forPath("/rb_malware/sequence-file/tasks");
            }

            hostname = InetAddress.getLocalHost().getHostName();
            if (client.checkExists().forPath("/rb_malware/seq-oozie") == null) {
                client.create().forPath("/rb_malware/seq-oozie");
            }

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public void run() {
        log.trace("At run method");
        status = Status.RUNNING;
        log.info("Status [" + status.name() + "]");
        while (status.equals(Status.RUNNING)) {
            log.info("Leader [" + leader.name() + "]");
            if (sequenceTasksHandler.isLeader()) {
                if (leader.equals(Leader.NOT_LEADER)) {
                    leader = Leader.LEADER;
                    log.info("Leader [" + leader.name() + "]");

                    try {
                        if (client.checkExists().forPath("/rb_malware/seq-oozie/leases") == null) {
                            client.create().forPath("/rb_malware/seq-oozie/leases");
                            client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/seq-oozie/leases");
                        } else {
                            client.delete().deletingChildrenIfNeeded().forPath("/rb_malware/seq-oozie/leases");
                            client.create().forPath("/rb_malware/seq-oozie/leases");
                            client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/seq-oozie/leases");
                        }

                        if (client.checkExists().forPath("/rb_malware/sequence-file/semaphore") != null) {
                            client.delete().deletingChildrenIfNeeded().forPath("/rb_malware/sequence-file/semaphore");
                            semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/sequence-file/semaphore", MAX_MULTIPLE_SEQ_FILE.intValue());
                        }
                    } catch (Exception e) {
                        log.error("", e);
                    }

                }
                try {

                    Task tasks = null;

                    Integer numS3Files = NUM_FILE_ON_SEQ;

                    StorageObjectsChunk inputChunk = s3Service.listObjectsChunked(bucket, "mdata/input", null, numS3Files, null, false);
                    LinkedList<StorageObject> inputObjects = new LinkedList<>(Arrays.asList(inputChunk.getObjects()));
                    LinkedList<StorageObject> checkObjects = new LinkedList<>(Arrays.asList(inputChunk.getObjects()));
                    int numDeletedObjects = 0;


                    for (StorageObject o : checkObjects) {
                        String file256sha = o.getKey().substring(("mdata/input/".length())).toLowerCase();
                        if (fileKnownChecker.isNeedToDelete(file256sha)) {
                            log.info("Deleted repeated file: " + file256sha);
                            s3Service.deleteObject(bucket, o.getKey());
                            TimeUnit.MILLISECONDS.sleep(500);
                            inputObjects.remove(o);
                            numDeletedObjects++;
                        }
                    }
                    LinkedList<StorageObject> mixedObjects;
                    LinkedList<StorageObject> analyzedObjects;
                    StorageObjectsChunk analyzedChunk;
                    if (inputObjects.size() < 1) {

                        analyzedChunk = s3Service.listObjectsChunked(bucket, "mdata/analyzed", null, numS3Files - inputObjects.size() + numDeletedObjects, null, false);
                        analyzedObjects = new LinkedList<>(Arrays.asList(analyzedChunk.getObjects()));

                        if (analyzedObjects.size() > 0) {

                            Date date = new Date();
                            SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd/HH");
                            String lastFile = null;
                            Date currentDate = new Date();
                            while (currentDate.getTime() >= (date.getTime() - (timeWindow * 3600 * 1000))) {
                                analyzedChunk = s3Service.listObjectsChunked(bucket, "mdata/analyzed/" + formatter.format(currentDate), null, 1, lastFile, false);
                                if (analyzedChunk.getObjects().length < 1) {
                                    log.debug("Empty bucket: " + "mdata/analyzed/" + formatter.format(currentDate));
                                    currentDate.setTime(currentDate.getTime() - (3600 * 1000));
                                } else {
                                    log.debug("Adding: " + analyzedChunk.getObjects()[0].getKey());
                                    lastFile = analyzedChunk.getObjects()[0].getKey();
                                    if (AeroSpikeManager.getInstance().isNeedToAnalyze(lastFile.substring(lastFile.lastIndexOf("/") + 1))) {
                                        inputObjects.addAll(new LinkedList<>(Arrays.asList(analyzedChunk.getObjects())));
                                    }
                                }
                                if (inputObjects.size() > 0) {
                                    break;
                                }
                            }
                        }
                    }

                    mixedObjects = inputObjects;
                    //if s3 is not empty
                    if (mixedObjects.size() > 0 || database.getBufferedObjects().size() > 0) {
                        log.debug("Number of S3Files to read [ " + numS3Files.toString() + " ]");
                        //Have peons finished?
                        log.trace("Acquiring at semaphore");
                        Lease lease = semaphore.acquire();
                        log.trace("After semaphore");
                        if (!status.equals(Status.RUNNING)) {
                            semaphore.returnLease(lease);
                        } else {
                            leases.add(lease);
                            log.debug("Number of leases: " + leases.size());
                            LinkedList<StorageObject> bufferedObjects = new LinkedList<>(database.getBufferedObjects());
                            int numBufferedObjects = database.getBufferedObjects().size();
                            int numInputS3files = numS3Files - numBufferedObjects;

                            if (numInputS3files < 0) {
                                numInputS3files = 0;
                            }
                            log.trace("The number of objects buffered is: " + numBufferedObjects);
                            inputChunk = s3Service.listObjectsChunked(bucket, "mdata/input", null, numInputS3files, null, false);
                            inputObjects = new LinkedList<>(Arrays.asList(inputChunk.getObjects()));
                            checkObjects = new LinkedList<>(Arrays.asList(inputChunk.getObjects()));
                            numDeletedObjects = 0;


                            for (StorageObject o : checkObjects) {

                                String file256sha = o.getKey().substring(("mdata/input/".length())).toLowerCase();
                                if (fileKnownChecker.isNeedToDelete(file256sha) || Collections.frequency(inputObjects, o) > 1 || database.isAnalyzing(o.getKey())) {
                                    log.info("Deleted repeated file: " + file256sha);
                                    s3Service.deleteObject(bucket, o.getKey());
                                    TimeUnit.MILLISECONDS.sleep(500);
                                    inputObjects.removeFirstOccurrence(o);
                                    numDeletedObjects++;
                                }
                            }

                            int numAnalyzedS3files = numInputS3files - inputObjects.size();


                            analyzedChunk = s3Service.listObjectsChunked(bucket, "mdata/analyzed", null, numS3Files - inputObjects.size() + numDeletedObjects, null, false);
                            analyzedObjects = new LinkedList<>(Arrays.asList(analyzedChunk.getObjects()));
                            if (analyzedObjects.size() > 0) {
                                analyzedObjects.clear();
                                DateTime date;
                                int numFilesAdded = 0;
                                List<String> filesAdded = new LinkedList<>();
                                int emptyFlag = 0;
                                while (numFilesAdded < numAnalyzedS3files) {

                                    date = new DateTime(DateTime.now().getYear(), DateTime.now().getMonthOfYear(), DateTime.now().getDayOfMonth(), DateTime.now().getHourOfDay(), 0);
                                    DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("yyyy/MM/dd/HH/");

                                    analyzedChunk = s3Service.listObjectsChunked(bucket, "mdata/analyzed/" + currentDate.toString(dateFormatter), null, 1, lastFile, false);
                                    if (analyzedChunk.getObjects().length < 1) {
                                        lastFile = null;
                                        log.debug("Reached end of bucket: " + "mdata/analyzed/" + currentDate.toString(dateFormatter));
                                        currentDate = currentDate.minusHours(1);
                                    } else {
                                        log.debug("Adding: " + analyzedChunk.getObjects()[0].getKey());
                                        if (filesAdded.contains(analyzedChunk.getObjects()[0].getKey())) {
                                            log.debug("There aren't more available files to add.");
                                            break;
                                        }
                                        String key = analyzedChunk.getObjects()[0].getKey();
                                        String sha256 = key.substring(key.lastIndexOf("/") + 1);
                                        lastFile = analyzedChunk.getObjects()[0].getKey();
                                        if (AeroSpikeManager.getInstance().isNeedToAnalyze(sha256)) {
                                            log.debug("File: " + sha256 + " need to be analyzed.");
                                            filesAdded.add(lastFile);
                                            numFilesAdded++;
                                            inputObjects.addAll(new LinkedList<>(Arrays.asList(analyzedChunk.getObjects())));
                                        } else {
                                            log.info("File: " + sha256 + " not need to be analyzed.");
                                        }
                                    }
                                    if (currentDate.getMillis() < (date.getMillis() - (timeWindow * 3600 * 1000))) {
                                        emptyFlag++;
                                        lastFile = null;
                                        currentDate = new DateTime(DateTime.now().getYear(), DateTime.now().getMonthOfYear(), DateTime.now().getDayOfMonth(), DateTime.now().getHourOfDay(), 0);
                                        log.debug("Time window has reached the last folder.");
                                        if (emptyFlag >= 2) {
                                            log.info("There aren't analyzed files inside time window.");
                                            break;
                                        }
                                    }
                                }

                            }

                            mixedObjects.clear();

                            if (numAnalyzedS3files == 0) {
                                analyzedObjects.clear();
                            }
                            if (numInputS3files == 0) {
                                inputObjects.clear();
                            }
                            if (numBufferedObjects > 0) {
                                mixedObjects = bufferedObjects;
                                database.removeBufferedObjects();
                            }
                            if (inputObjects.size() > 0) {
                                mixedObjects.addAll(inputObjects);
                            }
                            if (analyzedObjects.size() > 0) {
                                mixedObjects.addAll(analyzedObjects);
                            }
                            if (mixedObjects.size() > 0) {
                                List<StorageObject> objects = mixedObjects;
                                SequenceFile file = new SequenceFile();
                                log.debug("Number of mixed objects: " + mixedObjects.size());
                                int numberAnalyzing = 0;
                                long currentSize = 0;

                                for (StorageObject o : objects) {
                                    currentSize = currentSize + o.getContentLength();

                                    if (currentSize > (MAX_SEQ_FILE_SIZE * 1000000) && file.sizeNow() > 0) {
                                        currentSize = currentSize - o.getContentLength();
                                        database.addBufferedObject(o);
                                    } else {

                                        if (!database.isAnalyzing(o.getKey())) {
                                            StorageObject storageObject = new S3Object();
                                            storageObject.setBucketName(bucket);
                                            String path = o.getKey();
                                            String filename = "";
                                            String newFileName;
                                            String pathToFile = "mdata";
                                            if (path.contains("mdata/input")) {
                                                filename = path.substring((pathToFile + "/input/").length());
                                            } else if (path.contains("mdata/analyzed/")) {
                                                filename = path.substring((pathToFile + "/analyzed/").length());
                                            }
                                            DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd/HH/");
                                            Date date = new Date();
                                            String string_date = dateFormat.format(date);
                                            if (!path.contains("mdata/input")) {
                                                log.debug("File " + filename + " is not moved on S3.");
                                            } else {
                                                filename = string_date + filename;
                                            }

                                            newFileName = "mdata" + "/analyzed/" + filename;

                                            database.addEntry(newFileName);
                                            storageObject.setKey(newFileName);
                                            if (path.contains("mdata/input/")) {
                                                try {
                                                    log.debug("Moving S3 file " + path + " to " + newFileName);
                                                    s3Service.renameObject(bucket, path, storageObject);
                                                    S3Object s3Object = s3Service.getObject(bucket, newFileName);
                                                    byte[] bytes = IOUtils.toByteArray(s3Object.getDataInputStream());
                                                    String sha256 = DigestUtils.sha256Hex(bytes);
                                                    AeroSpikeManager.getInstance().put("malware", "controlFiles", sha256, newFileName);
                                                } catch (ServiceException e) {
                                                    log.error("", e);
                                                }
                                            }
                                            file.addS3FilePath(newFileName);
                                        } else {
                                            numberAnalyzing++;
                                        }
                                    }
                                }

                                if (numberAnalyzing == mixedObjects.size()) {
                                    log.info("All files are being analyzed");
                                    leases.remove(lease);
                                    semaphore.returnLease(lease);
                                    Thread.sleep(ONE_MINUTE / 2);
                                }
                                log.debug("File done and it has " + file.sizeNow() + " individual files. ");
                                file.done();

                                DateTime date = new DateTime();
                                String path = SEQUENCE_FILE_PATH + "/" + date.getYear() + "/" + date.getMonthOfYear() + "/" + date.getDayOfMonth() + "/" + date.getHourOfDay();
                                Long timestamp = System.currentTimeMillis();
                                String hash = DigestUtils.md5Hex(file.getS3FilesPaths().toString().getBytes());
                                String fileKey = timestamp + "-" + hash + ".seq";
                                file.setHDFSPath(path + "/" + fileKey);

                                database.addEntry(file.getHDFSPath(), file.getS3FilesPaths());

                                tasks = file;

                                int i = 0;
                                if (file.sizeNow() > 0) {
                                    log.debug("SETTING TASK: " + i);
                                    i++;
                                    byte[] aaa = mapper.writeValueAsBytes(file.asMap());
                                    taskName = UUID.randomUUID().toString();

                                    client.create().forPath("/rb_malware/sequence-file/tasks/" + taskName, mapper.writeValueAsBytes(file.asMap()));
                                    log.trace("Calling goToWork");
                                    sequenceTasksHandler.goToWork(true);

                                    task_assigned = " (" + tasks + ") ";
                                }
                            } else {
                                log.warn("Remove s3 files while I try to get them.... Remove lease!");
                                leases.remove(lease);
                                semaphore.returnLease(lease);
                            }
                        }
                    } else {
                        log.info("No s3 files ... Sleep [1 min]");
                        try {
                            Thread.sleep(ONE_MINUTE);
                        } catch (InterruptedException e) {
                            log.error("", e);
                        }
                    }
                } catch (ServiceException e) {
                    log.error("", e);
                } catch (Exception e) {
                    log.error("", e);
                }
            } else {
                try {
                    log.info("Sleeping... I'm not a leader!");
                    Thread.sleep(ONE_MINUTE);
                } catch (InterruptedException e) {
                    log.error("", e);
                }
            }
        }
    }

    public void closing() {
        status = Status.CLOSING;
        log.info("Status [" + status.name() + "]");
        sequenceManager.close();
    }

    public void close() {
        while (!leases.isEmpty()) {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                log.error("", e);
            }
            log.info("Waiting while ooziePeons ending ... OoziePeons running #" + leases.size());
        }

        sequenceTasksHandler.end();
        client.close();
        status = Status.CLOSE;
        log.info("Status [" + status.name() + "]");

    }

    public void reload() {
        NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
        timeWindow = ((Integer) ConfigFile.getInstance().getFromGeneral("time_window", 4)).longValue();
        MAX_MULTIPLE_SEQ_FILE = ConfigFile.getInstance().getFromGeneral("max_multiple_seq_file", 1);
        MAX_SEQ_FILE_SIZE = ((Integer) ConfigFile.getInstance().getFromGeneral("max_seq_file_size", 8)).longValue();
    }

    public class LeaseWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {
            log.info(Thread.currentThread().getId() + " [WATCH] LeasesWatcher: " + watchedEvent);
            Watcher.Event.EventType type = watchedEvent.getType();
            if (type.equals(Watcher.Event.EventType.NodeChildrenChanged)) {
                log.debug("Leases added!");
                if (sequenceTasksHandler.isLeader()) {

                    String eventPath = watchedEvent.getPath() + "/" + client.getChildren().forPath(watchedEvent.getPath()).get(0);
                    byte[] zkData = client.getData().forPath(eventPath);
                    client.delete().forPath(eventPath);

                    //String contained at zk
                    String str = new String(zkData, "UTF-8");

                    log.info("Oozie Job finished:  [" + str + "]");

                    //Recolect s3objects that have been analyzed and put metadata info "analyzing" to "no"
                    Map<String, Object> data = mapper.readValue(str, Map.class);
                    String path = (String) data.get("idjob");
                    //Delete files that have been analyzed from database
                    Boolean mustLeave = database.removeEntry(path);

                    if (mustLeave && leases.size() > 0) {
                        log.info("REMOVE LEASE!");
                        semaphore.returnLease(leases.remove());
                    }
                    barrierOozieSeq.removeBarrier();
                }
            }

            if (client.getState().equals(CuratorFrameworkState.STARTED)) {
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/seq-oozie/leases");
            }
        }
    }
}
