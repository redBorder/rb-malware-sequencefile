package net.redborder.malware.sequencefile.leader;

import net.redborder.malware.sequencefile.SequenceFile;
import net.redborder.malware.sequencefile.peons.SequenceManager;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.taskassigner.Task;
import net.redborder.taskassigner.ZkTasksHandler;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;
import org.apache.curator.framework.recipes.locks.Lease;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.jets3t.service.S3Service;
import org.jets3t.service.ServiceException;
import org.jets3t.service.StorageObjectsChunk;
import org.jets3t.service.impl.rest.httpclient.RestS3Service;
import org.jets3t.service.model.StorageObject;
import org.jets3t.service.security.AWSCredentials;

import java.util.*;

public class SequenceLeader extends Thread {
    private static final long ONE_MINUTE = 60000;
    private static final Long NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
    private static final Long SEQ_FILE_ON_WORKERS = ConfigFile.getInstance().getFromGeneral("seq_file_from_workers");
    private ZkTasksHandler tasksHandler;
    private SequenceManager sequenceManager;
    private Boolean running = false;
    private Queue<Lease> leases;
    AWSCredentials awsCredentials;
    S3Service s3Service;
    InterProcessSemaphoreV2 semaphore;
    CuratorFramework client;
    LeaseWatcher leaseWatcher;


    public SequenceLeader() {
        init();
    }

    private void init() {
        awsCredentials = new AWSCredentials((String) ConfigFile.getInstance().getFromGeneral("aws_access"), (String) ConfigFile.getInstance().getFromGeneral("aws_secret"));
        tasksHandler = new ZkTasksHandler(ConfigFile.getInstance().getZkConnect(), "/rb-malware/sequence-file");
        sequenceManager = new SequenceManager();
        tasksHandler.addListener(sequenceManager);
        running = true;
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        Integer max_seq_files = tasksHandler.numWorkers() * SEQ_FILE_ON_WORKERS.intValue();
        semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/semaphore", max_seq_files);
        leases = new LinkedList<>();
        leaseWatcher = new LeaseWatcher();
        try {
            if (client.checkExists().forPath("/rb-malware/leases") == null) {
                client.create().withMode(CreateMode.EPHEMERAL).forPath("/rb-malware/leases");
                client.getData().usingWatcher(leaseWatcher).forPath("/rb-malware/leases");
            } else {
                client.getData().usingWatcher(leaseWatcher).forPath("/rb-malware/leases");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public synchronized void start() {
        super.start();
        sequenceManager.start();
        s3Service = new RestS3Service(awsCredentials);
    }

    @Override
    public void run() {
        while (running) {
            if (tasksHandler.isLeader()) {
                try {
                    List<Task> tasks = new ArrayList<Task>();
                    Integer numWorkers = tasksHandler.numWorkers();

                    Long numS3Files = NUM_FILE_ON_SEQ * numWorkers * SEQ_FILE_ON_WORKERS;

                    StorageObjectsChunk inputChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/input", null, numS3Files, null, false);
                    StorageObject inputObjects[] = inputChunk.getObjects();

                    if (inputObjects.length > 0) {
                        List<StorageObject> objects = Arrays.asList(inputObjects);
                        Collections.reverse(objects);

                        SequenceFile file = new SequenceFile();
                        int i = 0;

                        for (StorageObject o : objects) {
                            if (i < NUM_FILE_ON_SEQ) {
                                file.addS3FilePath(o.getKey());
                                i++;
                            } else {
                                Lease lease = semaphore.acquire();
                                leases.add(lease);
                                file.saveS3FilesPaths();
                                tasks.add(file);
                                file = new SequenceFile();
                                file.addS3FilePath(o.getKey());
                                i = 1;
                            }
                        }
                    }

                    if (numS3Files - inputObjects.length >= NUM_FILE_ON_SEQ) {
                        StorageObjectsChunk analizedChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/analized", null, numS3Files, null, false);
                        StorageObject analizedObjects[] = analizedChunk.getObjects();

                        if (analizedObjects.length > 0) {
                            List<StorageObject> objects = Arrays.asList(analizedObjects);
                            Collections.reverse(objects);


                            SequenceFile file = new SequenceFile();
                            int i = 0;

                            for (StorageObject o : objects) {
                                if (i < NUM_FILE_ON_SEQ) {
                                    file.addS3FilePath(o.getKey());
                                    i++;
                                } else {
                                    Lease lease = semaphore.acquire();
                                    leases.add(lease);
                                    file.saveS3FilesPaths();
                                    tasks.add(file);
                                    file = new SequenceFile();
                                    file.addS3FilePath(o.getKey());
                                    i = 1;
                                }
                            }
                        }
                    }

                    if (tasks.size() > 0) {
                        tasksHandler.setTasks(tasks);
                        tasksHandler.wakeup();
                    }
                } catch (ServiceException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    Thread.sleep(ONE_MINUTE);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void close() {
        running = false;
        sequenceManager.close();
    }

    public class LeaseWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {
            System.out.println(Thread.currentThread().getId() + " [WATCH] WorkersWatcher: " + watchedEvent);
            Watcher.Event.EventType type = watchedEvent.getType();

            if (type.equals(Watcher.Event.EventType.NodeChildrenChanged)) {
                System.out.print("Leases added!");
                if(tasksHandler.isLeader()){
                    // TODO Detectar que fichero sequencial se ha terminado.
                    semaphore.returnLease(leases.remove());
                }else{
                    System.out.println(" But im not the leader, so lets ignore it.");
                }
            }

            if (client.getState().equals(CuratorFrameworkState.STARTED)) {
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb-malware/leases");
            }
        }
    }
}
