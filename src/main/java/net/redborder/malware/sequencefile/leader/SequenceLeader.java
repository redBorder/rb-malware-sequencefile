package net.redborder.malware.sequencefile.leader;

import net.redborder.malware.sequencefile.SequenceFile;
import net.redborder.malware.sequencefile.managers.SequenceManager;
import net.redborder.malware.sequencefile.util.ConfigFile;
import net.redborder.malware.sequencefile.util.logger.RbLogger;
import net.redborder.taskassigner.Task;
import net.redborder.taskassigner.ZkTasksHandler;
import org.apache.commons.lang.ArrayUtils;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;
import org.apache.curator.framework.recipes.locks.Lease;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;
import org.jets3t.service.S3Service;
import org.jets3t.service.ServiceException;
import org.jets3t.service.StorageObjectsChunk;
import org.jets3t.service.impl.rest.httpclient.RestS3Service;
import org.jets3t.service.model.S3Object;
import org.jets3t.service.model.StorageObject;
import org.jets3t.service.security.AWSCredentials;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;


public class SequenceLeader extends Thread {
    private static final long ONE_MINUTE = 60000;
    private static final Integer NUM_FILE_ON_SEQ = SequenceFile.getSequenceFileLenght();
    private static final Integer SEQ_FILE_ON_WORKERS = ConfigFile.getInstance().getFromGeneral("seq_file_on_workers");
    private ZkTasksHandler sequenceTasksHandler;
    private SequenceManager sequenceManager;
    private Boolean running = false;
    private Queue<Lease> leases;
    AWSCredentials awsCredentials;
    S3Service s3Service;
    InterProcessSemaphoreV2 semaphore;
    CuratorFramework client;
    LeaseWatcher leaseWatcher;
    private Logger log = null;
    int i = 1;
    S3Object s3Object = null;
    String hostname;
    ObjectMapper mapper;
    String task_assigned;
    String taskName = null;
    public SequenceLeader() {
        init();
    }

    private void init() {
        mapper = new ObjectMapper();
        log = RbLogger.getLogger(SequenceLeader.class.getName());
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(ConfigFile.getInstance().getZkConnect(), retryPolicy);
        client.start();
        awsCredentials = new AWSCredentials((String) ConfigFile.getInstance().getFromGeneral("aws_access"), (String) ConfigFile.getInstance().getFromGeneral("aws_secret"));
        s3Service = new RestS3Service(awsCredentials);

        sequenceTasksHandler = new ZkTasksHandler(ConfigFile.getInstance().getZkConnect(), "/rb_malware/sequence-file");
        sequenceManager = new SequenceManager();
        System.out.println("Added Sequence manager listener");
        sequenceTasksHandler.addListener(sequenceManager);
        System.out.println("NUM WORKERS: " + sequenceTasksHandler.numWorkers());
        Integer max_seq_files = sequenceTasksHandler.numWorkers() * SEQ_FILE_ON_WORKERS.intValue();
        semaphore = new InterProcessSemaphoreV2(client, "/rb_malware/semaphore", max_seq_files);
        leases = new LinkedList<>();
        leaseWatcher = new LeaseWatcher();
        try {
            if (client.checkExists().forPath("/rb_malware/tasks") == null) {

                client.create().forPath("/rb_malware/tasks");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            hostname= InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
        try {
            if (client.checkExists().forPath("/rb_malware/leases") == null) {
                client.create().forPath("/rb_malware/leases");
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/leases");
            } else {
                client.delete().forPath("/rb_malware/leases");
                System.out.println("Exists old state, I recovery and create again!");
                client.create().forPath("/rb_malware/leases");
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/leases");
            }

            Thread.sleep(10000);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        running = true;

    }

    @Override
    public synchronized void start() {
        super.start();
        sequenceManager.start();
    }

    @Override
    public void run() {
        while (running) {
            System.out.println("LEADER: " + sequenceTasksHandler.isLeader());
            if (sequenceTasksHandler.isLeader()) {
                try {
                 Task tasks = null;

                    Integer numS3Files = NUM_FILE_ON_SEQ;



                    StorageObjectsChunk inputChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/input", null, numS3Files, null, false);
                    StorageObject inputObjects[] = inputChunk.getObjects();
                    StorageObjectsChunk analyzedChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/analyzed", null, numS3Files - inputObjects.length, null, false);
                    StorageObject analyzedObjects[] = analyzedChunk.getObjects();
                    StorageObject mixedObjects[];
                    mixedObjects = (StorageObject[]) ArrayUtils.addAll(inputObjects, analyzedObjects);

                    if(mixedObjects.length>0) {
                        log.log(Level.INFO, "Number of S3Files to read [ " + numS3Files.toString() + " ]");
                        //Have peons finished?
                        Lease lease = semaphore.acquire();
                        leases.add(lease);
                        log.log(Level.INFO, "Number of leases: " + leases.size());

                        inputChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/input", null, numS3Files, null, false);
                        inputObjects = inputChunk.getObjects();
                        analyzedChunk = s3Service.listObjectsChunked("redborder", "rbdata/rb_malware/analyzed", null, numS3Files - inputObjects.length, null, false);
                        analyzedObjects = analyzedChunk.getObjects();
                        if((numS3Files-inputObjects.length)>0) {
                            mixedObjects = (StorageObject[]) ArrayUtils.addAll(inputObjects, analyzedObjects);
                        }else{
                            mixedObjects = inputObjects;
                        }


                        if (mixedObjects.length > 0) {
                            List<StorageObject> objects = Arrays.asList(mixedObjects);
                            Collections.reverse(objects);

                            SequenceFile file = new SequenceFile();
                            log.log(Level.INFO, "Number of mixed objects: " + mixedObjects.length);

                            for (StorageObject o : objects) {
                                StorageObject storageObject = new S3Object();
                                storageObject.setBucketName("redborder");
                                String path = o.getKey();
                                String filename = "";
                                String newFileName;
                                String  pathToFile =  "rbdata/rb_malware";
                                if(path.contains("rbdata/rb_malware/input")) {
                                    filename = path.substring((pathToFile + "/input/").length());
                                }else if (path.contains("rbdata/rb_malware/analyzed/")){
                                    filename = path.substring((pathToFile + "/analyzed/").length());
                                }

                                    newFileName = "rbdata/rb_malware" + "/analyzing/" + filename;

                                log.log(Level.INFO, "Moving S3 file " + path + " to " + newFileName);
                                storageObject.setKey(newFileName);
                                s3Service.renameObject("redborder", path, storageObject);
                                file.addS3FilePath(newFileName);
                            }

                            log.log(Level.INFO, "File done and it has " + file.sizeNow() + " individual files. ");
                            file.done();
                            tasks=file;



                            if (file.sizeNow()>0) {
                                log.log(Level.INFO, "SETTING TASK: " + i);
                                i++;

                                taskName = UUID.randomUUID().toString();
                                System.out.println("TaskName es: "+taskName);
                                System.out.println("File es : "+ file.sizeNow());
                                client.create().forPath("/rb_malware/tasks/" + taskName, mapper.writeValueAsBytes(file.asMap()));
                                sequenceTasksHandler.goToWork(true);

                                task_assigned = " (" + tasks + ") ";

                            }
                        }
                    }else{
                        String message = "Waiting for files at S3";
                        for(int i = 0; i<5; i++) {

                            System.out.print(message);
                            message=".";
                            Thread.sleep(2000);
                        }
                        System.out.println("");
                    }
                } catch (ServiceException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                try {
                    log.log(Level.INFO, "Sleeping...");

                    Thread.sleep(ONE_MINUTE);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void close() {
        running = false;
        sequenceManager.close();
    }

    public class LeaseWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {
            System.out.println(Thread.currentThread().getId() + " [WATCH] WorkersWatcher: " + watchedEvent);
            Watcher.Event.EventType type = watchedEvent.getType();
            if (type.equals(Watcher.Event.EventType.NodeChildrenChanged)) {
                System.out.println("Leases added!");
                if (sequenceTasksHandler.isLeader()) {
                    String eventPath =  watchedEvent.getPath() + "/" + client.getChildren().forPath(watchedEvent.getPath()).toString().replace("[", "").replace("]","");
                    byte[] zkData = client.getData().forPath(eventPath);
                    client.delete().forPath(eventPath);

                    //String contained at zk
                    // String str = new String(zkData, "UTF-8");

                    log.log(Level.INFO, "Oozie Manager has finished!");

                    semaphore.returnLease(leases.remove());
                } else {
                    System.out.println(" But im not the leader, so lets ignore it.");
                }
            }

            if (client.getState().equals(CuratorFrameworkState.STARTED)) {
                client.getChildren().usingWatcher(leaseWatcher).forPath("/rb_malware/leases");
            }
        }
    }
}
