package net.redborder.malware.sequencefile.util.aerospike;

/**
 * Created by Lito on 20/7/15.
 */

import com.aerospike.client.*;
import com.aerospike.client.Record;
import com.aerospike.client.async.AsyncClient;
import com.aerospike.client.async.AsyncClientPolicy;
import com.aerospike.client.listener.ExistsListener;
import com.aerospike.client.policy.Policy;
import com.aerospike.client.policy.RecordExistsAction;
import com.aerospike.client.policy.WritePolicy;
import net.redborder.malware.sequencefile.util.ConfigFile;
import org.apache.log4j.Logger;
import org.ho.yaml.Yaml;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class AeroSpikeManager {
    private static final Logger log = Logger.getLogger(AeroSpikeManager.class);
    final String AEROSPIKE_CONFIG_FILE = "/opt/rb/var/rb-sequence-oozie/conf/aerospike.yml";
    AsyncClient client;
    List<String> hosts;
    Integer timeout;
    WritePolicy writePolicy;
    private static AeroSpikeManager theInstance = null;
    private int threshold;


    public static AeroSpikeManager getInstance() {
        if (theInstance == null) {

            int retry = 0;

            do {
                try {
                    theInstance = new AeroSpikeManager();
                    break;
                } catch (AerospikeException e) {
                    retry++;
                    log.info("Error to init AeroSpike connection [" + e.getMessage() + "], retry in 15 seconds: retries #" + retry);
                    try {
                        TimeUnit.SECONDS.sleep(15);
                    } catch (InterruptedException e1) {
                        log.error("", e1);
                    }
                }
            } while (retry <= 10);
        }
        return theInstance;
    }


    public AeroSpikeManager() {

        Map<String, Object> aeroSpikeConfig = loadAeroSpikeConfig();
        this.hosts = (List<String>) aeroSpikeConfig.get("servers");
        this.timeout = (Integer) aeroSpikeConfig.get("timeout");
        this.writePolicy = new WritePolicy();
        this.writePolicy.recordExistsAction = RecordExistsAction.UPDATE;
        init();
    }

    private Map<String, Object> loadAeroSpikeConfig() {
        Map<String, Object> map = null;
        try {
            map = (Map<String, Object>) Yaml.load(new File(AEROSPIKE_CONFIG_FILE));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        Map<String, Object> general = (Map<String, Object>) map.get("general");
        return (Map<String, Object>) general.get("aerospike");
    }

    private void init() {
        List<Host> servers = new ArrayList<>();

        for (String host : hosts) {
            String[] sp = host.split(":");
            servers.add(new Host(sp[0], Integer.parseInt(sp[1])));
        }

        AsyncClientPolicy cPolicy = new AsyncClientPolicy();
        cPolicy.timeout = timeout;

        client = new AsyncClient(cPolicy, servers.toArray(new Host[servers.size()]));
        this.threshold = ((Integer) ConfigFile.getInstance().getFromGeneral("malware_threshold", 80));
    }


    public void put(String namespace, String collection, String key, List<String> columns, List<Object> values) {
        put(namespace, collection, key, columns, values, RecordExistsAction.UPDATE);
    }

    public void put(String namespace, String collection, String key, String s3URI) {
        List<String> columns = new ArrayList<>();
        List<Object> values = new ArrayList<>();
        columns.add("hash");
        columns.add("s3_uri");
        values.add(key);
        values.add(s3URI);
        put(namespace, collection, key, columns, values, RecordExistsAction.UPDATE);
    }

    public boolean exist(String namespace, String collection, String key) {
        return client.exists(new Policy(), new Key(namespace, collection, key));
    }

    public void exist(String namespace, String collection, String key, ExistsListener existsListener) {
        client.exists(new Policy(), existsListener, new Key(namespace, collection, key));
    }

    public boolean isNeedToDelete(String key) {
        Boolean needToDelete = exist("malware", "controlFiles", key);
        return needToDelete;
    }

    public boolean isNeedToAnalyze(String key) {
        log.debug("Key: " + key);
        Map<String, Object> data = this.get("malware", "hashScores", key);
        return data == null;
    }


    public Map<String, Object> get(String namespace, String collection, String key) {
        Record record = client.get(new Policy(), new Key(namespace, collection, key));
        if (record != null) {
            return record.bins;
        } else {
            return null;
        }
    }

    public Map<String, Object> getMalwareCache(String namespace, String collection, String key) {
        Record record = client.get(new Policy(), new Key("malware", "controlFiles", key));
        return record.bins;
    }


    public void put(String namespace, String collection, String key, List<String> columns, List<Object> values, RecordExistsAction action) {
        Key asKey = new Key(namespace, collection, key);
        Bin[] bins = new Bin[columns.size()];

        WritePolicy policy = new WritePolicy();
        policy.recordExistsAction = action;

        for (int i = 0; i < columns.size(); i++) {
            bins[i] = new Bin(columns.get(i), values.get(i));
        }

        client.put(policy, asKey, bins);
    }


    public void increment(String namespace, String collection, String key, List<String> columns, List<Integer> values) {
        Key asKey = new Key(namespace, collection, key);
        Operation[] operations = new Operation[columns.size()];

        WritePolicy policy = new WritePolicy();
        policy.recordExistsAction = RecordExistsAction.UPDATE;

        for (int i = 0; i < columns.size(); i++) {
            operations[i] = Operation.add(new Bin(columns.get(i), values.get(i)));
        }

        client.operate(policy, asKey, operations);
    }


    public void decrement(String s, String s1, String s2, List<String> list, List<Integer> list1) {
    }

    public void reload() {
        this.threshold = ((Integer) ConfigFile.getInstance().getFromGeneral("malware_threshold", 80));
    }


    public Object getClient() {
        return client;
    }
}
